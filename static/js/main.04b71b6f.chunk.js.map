{"version":3,"sources":["FoodImage/FoodImage.js","FoodsContainer/FoodsContainer.js","WorldMap/WorldMap.js","App.js","serviceWorker.js","index.js"],"names":["FoodImage","props","isSelected","selected","alt","className","src","link","onClick","e","FoodsContainer","item","event","key","image","items","this","foods","map","i","renderFoodItem","Fragment","Component","WorldMap","colors","markers","green","L","icon","iconUrl","iconSize","red","blue","orange","place","color","position","lat","lng","Marker","Popup","name","synonyms","markerColors","currentColorIndex","places","p","s","hasOwnProperty","renderMarker","Map","center","zoom","TileLayer","attribution","url","App","componentDidMount","setState","loading","data","all","readJson","jsonPath","then","console","log","sort","comparePlaceFrequency","images","o","handleClick","el","selectedFood","currentTarget","find","state","a","b","length","aSyns","bSyns","concat","aUnique","filter","value","index","self","indexOf","bUnique","path","fetch","response","ok","Error","status","json","catch","role","aria-label","href","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.04b71b6f.chunk.js","sourcesContent":["import React from 'react';\nimport './FoodImage.css';\n\nexport default function FoodImage(props) {\n  const isSelected = props.selected === props.alt;\n  return (\n    <li className={isSelected ? 'selected' : ''}>\n      <img\n        src={props.link}\n        alt={props.alt}\n        onClick={(e) => props.onClick(e)}\n      />\n      <span>{props.alt}</span>\n    </li>\n  );\n}\n","import React, { Component } from 'react';\nimport FoodImage from '../FoodImage/FoodImage'\nimport './FoodsContainer.css';\n\nclass FoodsContainer extends Component {\n\n  renderFoodItem(item, event, selected) {\n    return (\n      <FoodImage\n        key={item.key}\n        link={item.image}\n        alt={item.key}\n        onClick={event}\n        selected={selected}\n      />\n    );\n  }\n\n  render(props) {\n    const items = this.props.foods.map((i) => {\n      return this.renderFoodItem(i, this.props.onClick, this.props.selected);\n    });\n\n    return (\n      <React.Fragment>\n        <p><strong>Selected food:</strong> {this.props.selected}</p>\n        <section className=\"FoodsContainer\">\n          <ul>\n            {items}\n          </ul>\n        </section>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default FoodsContainer;\n","import React, { Component } from 'react';\nimport L from 'leaflet'\nimport {Map, TileLayer, Marker, Popup } from 'react-leaflet';\nimport './WorldMap.css';\n\nclass WorldMap extends Component {\n  constructor(props) {\n    super(props);\n    this.colors = [\n      'green',\n      'red',\n      'blue',\n      'orange'\n    ]\n    this.markers = {\n      green: L.icon({\n          iconUrl: 'iconGreen.png',\n          iconSize: [20, 20],\n      }),\n      red: L.icon({\n          iconUrl: 'iconRed.png',\n          iconSize: [20, 20],\n      }),\n      blue: L.icon({\n          iconUrl: 'iconBlue.png',\n          iconSize: [20, 20],\n      }),\n      orange: L.icon({\n          iconUrl: 'iconOrange.png',\n          iconSize: [20, 20],\n      }),\n    }\n  }\n\n\n  renderMarker(place, color) {\n    const position = [place.lat, place.lng];\n    return(\n        <Marker key={position[0]+position[1]} position={position} icon={this.markers[color]}>\n          <Popup>\n            {place.name} <br/> {place.synonyms}\n          </Popup>\n        </Marker>\n      )\n\n  }\n\n  render(props) {\n    // console.log(this.props);\n    // console.log(this.props.places);\n    const markerColors = {}\n    let currentColorIndex = 0\n    const markers = this.props.places.map((p) => {\n      let color;\n      for (let s of p.synonyms) {\n        if(markerColors.hasOwnProperty(s)){\n          color = markerColors[s];\n        } else {\n          markerColors[s] = this.colors[currentColorIndex]\n          color = markerColors[s];\n          currentColorIndex += 1;\n        }\n      }\n      return this.renderMarker(p, color)\n    })\n    const zoom = 3;\n    const lat = 40.730610;\n    const lng = -73.935242;\n    const position = [lat, lng];\n    return (\n      <Map center={position} zoom={zoom}>\n        <TileLayer\n          attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n        />\n        {markers}\n      </Map>\n    );\n  }\n}\n\nexport default WorldMap;\n","import React, { Component } from 'react';\nimport FoodsContainer from './FoodsContainer/FoodsContainer';\nimport WorldMap from './WorldMap/WorldMap';\n// import Map from './Map/Map'\n\nimport './App.css';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.data = {\n      images: [],\n      all: {}\n    };\n    this.state = {\n      selectedFood: 'almond',\n      places: [],\n      loading: true,\n    };\n    this.jsonPath = 'distribution.json';\n  };\n\n  componentDidMount = () => {\n    this.setState({loading: true});\n    this.data.all = this.readJson(this.jsonPath)\n      .then((data) => {\n        this.data.all = data\n        console.log('original data', this.data.all);\n        this.data.all.sort(this.comparePlaceFrequency);\n        // this.data.all.sort(this.compareSynonymFrequency);\n        console.log('after sort', this.data.all);\n        this.data.images = data.map((o) => {\n          const n = {\n            key: o.key,\n            image: o.image\n          }\n          return n;\n        });\n        console.log('The data was loaded', this.data.all, this.data.images);\n        this.setState({loading: false});\n      });\n  };\n\n\n  comparePlaceFrequency(a, b) {\n    if (a.places.length > b.places.length) {\n      return -1;\n    }\n    return 1;\n  }\n\n  compareSynonymFrequency(a, b) {\n    let aSyns = [];\n    let bSyns = [];\n    aSyns.concat(a.places.map(p => p.synonyms));\n    bSyns.concat(b.places.map(p => p.synonyms));\n\n    var aUnique = aSyns.filter( (value, index, self) => {\n        return self.indexOf(value) === index;\n    } );\n    var bUnique = bSyns.filter( (value, index, self) => {\n        return self.indexOf(value) === index;\n    } );\n    console.log(aUnique);\n    console.log(bUnique);\n\n\n   if (aUnique.length > bUnique.length) {\n      return 1;\n    }\n    return -1;\n  }\n\n  handleClick = (el) =>  {\n    this.setState({\n      selectedFood: el.currentTarget.alt,\n      places: (this.data.all.find((o) => o.key===el.currentTarget.alt)).places\n    });\n  }\n\n  readJson(path) {\n     return fetch(path)\n     .then(response => {\n         if (!response.ok) {\n             throw new Error(\"HTTP error \" + response.status);\n         }\n         return response.json();\n     })\n     .catch(function () {\n         throw new Error(\"File not available\");\n     })\n  }\n\n  render() {\n    if (this.state.loading === true) {\n      return <h2>Loading...</h2>;\n    }\n\n\n    return (\n      <React.Fragment>\n        <header>\n          <h1>Food language variety visualization</h1>\n        </header>\n        <main>\n          <aside>\n            <FoodsContainer\n              foods={this.data.images}\n              onClick={this.handleClick}\n              selected={this.state.selectedFood}\n            />\n          </aside>\n          <WorldMap places={this.state.places} />\n        </main>\n        <footer>\n          <p>Made with <span role=\"img\" aria-label=\"love\">💖</span> by <a href=\"https://github.com/nmicht/\">@nmicht</a> and <a href=\"https://github.com/jbrew/\">@jbrew</a> at NYC</p>\n          <p>Data obtained from Wikipedia. Project licensed under MIT.</p>\n          <p><a href=\"https://github.com/nmicht/food-language-variety\">Fork from github</a></p>\n        </footer>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}