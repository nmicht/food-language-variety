{"version":3,"sources":["FoodImage/FoodImage.js","FoodsContainer/FoodsContainer.js","WorldMap/WorldMap.js","App.js","serviceWorker.js","index.js"],"names":["FoodImage","props","isSelected","selected","alt","react_default","a","createElement","className","src","link","onClick","e","FoodsContainer","item","event","FoodImage_FoodImage","key","image","_this","this","items","foods","map","i","renderFoodItem","Fragment","Component","WorldMap","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","colors","markers","green","L","icon","iconUrl","iconSize","red","blue","orange","place","color","position","lat","lng","Marker","Popup","name","synonyms","_this2","markerColors","currentColorIndex","places","p","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","s","value","hasOwnProperty","err","return","renderMarker","Map","center","zoom","TileLayer","attribution","url","App","componentDidMount","setState","loading","data","all","readJson","jsonPath","then","console","log","sort","comparePlaceFrequency","images","o","handleClick","el","selectedFood","currentTarget","find","state","b","length","aSyns","bSyns","concat","aUnique","filter","index","self","indexOf","bUnique","path","fetch","response","ok","Error","status","json","catch","src_FoodsContainer_FoodsContainer","src_WorldMap_WorldMap","href","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"qUAGe,SAASA,EAAUC,GAChC,IAAMC,EAAaD,EAAME,WAAaF,EAAMG,IAC5C,OACEC,EAAAC,EAAAC,cAAA,MAAIC,UAAWN,EAAa,WAAa,IACvCG,EAAAC,EAAAC,cAAA,OACEE,IAAKR,EAAMS,KACXN,IAAKH,EAAMG,IACXO,QAAS,SAACC,GAAD,OAAOX,EAAMU,QAAQC,MAEhCP,EAAAC,EAAAC,cAAA,YAAON,EAAMG,gBCwBJS,yLA9BEC,EAAMC,EAAOZ,GAC1B,OACEE,EAAAC,EAAAC,cAACS,EAAD,CACEC,IAAKH,EAAKG,IACVP,KAAMI,EAAKI,MACXd,IAAKU,EAAKG,IACVN,QAASI,EACTZ,SAAUA,mCAKTF,GAAO,IAAAkB,EAAAC,KACNC,EAAQD,KAAKnB,MAAMqB,MAAMC,IAAI,SAACC,GAClC,OAAOL,EAAKM,eAAeD,EAAGL,EAAKlB,MAAMU,QAASQ,EAAKlB,MAAME,YAG/D,OACEE,EAAAC,EAAAC,cAACF,EAAAC,EAAMoB,SAAP,KACErB,EAAAC,EAAAC,cAAA,SAAGF,EAAAC,EAAAC,cAAA,gCAAH,IAAoCa,KAAKnB,MAAME,UAC/CE,EAAAC,EAAAC,cAAA,WAASC,UAAU,kBACjBH,EAAAC,EAAAC,cAAA,UACGc,YAxBgBM,6DC6EdC,qBA3Eb,SAAAA,EAAY3B,GAAO,IAAAkB,EAAA,OAAAU,OAAAC,EAAA,EAAAD,CAAAT,KAAAQ,IACjBT,EAAAU,OAAAE,EAAA,EAAAF,CAAAT,KAAAS,OAAAG,EAAA,EAAAH,CAAAD,GAAAK,KAAAb,KAAMnB,KACDiC,OAAS,CACZ,QACA,MACA,OACA,UAEFf,EAAKgB,QAAU,CACbC,MAAOC,IAAEC,KAAK,CACVC,QAAS,gBACTC,SAAU,CAAC,GAAI,MAEnBC,IAAKJ,IAAEC,KAAK,CACRC,QAAS,cACTC,SAAU,CAAC,GAAI,MAEnBE,KAAML,IAAEC,KAAK,CACTC,QAAS,eACTC,SAAU,CAAC,GAAI,MAEnBG,OAAQN,IAAEC,KAAK,CACXC,QAAS,iBACTC,SAAU,CAAC,GAAI,OAvBJrB,4EA6BNyB,EAAOC,GAClB,IAAMC,EAAW,CAACF,EAAMG,IAAKH,EAAMI,KACnC,OACI3C,EAAAC,EAAAC,cAAC0C,EAAA,EAAD,CAAQhC,IAAK6B,EAAS,GAAGA,EAAS,GAAIA,SAAUA,EAAUR,KAAMlB,KAAKe,QAAQU,IAC3ExC,EAAAC,EAAAC,cAAC2C,EAAA,EAAD,KACGN,EAAMO,KADT,IACe9C,EAAAC,EAAAC,cAAA,WADf,IACsBqC,EAAMQ,0CAO7BnD,GAAO,IAAAoD,EAAAjC,KAGNkC,EAAe,GACjBC,EAAoB,EAClBpB,EAAUf,KAAKnB,MAAMuD,OAAOjC,IAAI,SAACkC,GACrC,IAAIZ,EADuCa,GAAA,EAAAC,GAAA,EAAAC,OAAAC,EAAA,IAE3C,QAAAC,EAAAC,EAAcN,EAAEL,SAAhBY,OAAAC,cAAAP,GAAAI,EAAAC,EAAAG,QAAAC,MAAAT,GAAA,EAA0B,KAAjBU,EAAiBN,EAAAO,MACrBf,EAAagB,eAAeF,GAC7BvB,EAAQS,EAAac,IAErBd,EAAac,GAAKf,EAAKnB,OAAOqB,GAC9BV,EAAQS,EAAac,GACrBb,GAAqB,IARkB,MAAAgB,GAAAZ,GAAA,EAAAC,EAAAW,EAAA,YAAAb,GAAA,MAAAK,EAAAS,QAAAT,EAAAS,SAAA,WAAAb,EAAA,MAAAC,GAW3C,OAAOP,EAAKoB,aAAahB,EAAGZ,KAKxBC,EAAW,CAFL,UACC,WAEb,OACEzC,EAAAC,EAAAC,cAACmE,EAAA,EAAD,CAAKC,OAAQ7B,EAAU8B,KALZ,GAMTvE,EAAAC,EAAAC,cAACsE,EAAA,EAAD,CACEC,YAAY,yEACZC,IAAI,4CAEL5C,UAtEcR,cCqHRqD,qBAlHb,SAAAA,EAAY/E,GAAO,IAAAkB,EAAA,OAAAU,OAAAC,EAAA,EAAAD,CAAAT,KAAA4D,IACjB7D,EAAAU,OAAAE,EAAA,EAAAF,CAAAT,KAAAS,OAAAG,EAAA,EAAAH,CAAAmD,GAAA/C,KAAAb,KAAMnB,KAaRgF,kBAAoB,WAClB9D,EAAK+D,SAAS,CAACC,SAAS,IACxBhE,EAAKiE,KAAKC,IAAMlE,EAAKmE,SAASnE,EAAKoE,UAChCC,KAAK,SAACJ,GACLjE,EAAKiE,KAAKC,IAAMD,EAChBK,QAAQC,IAAI,gBAAiBvE,EAAKiE,KAAKC,KACvClE,EAAKiE,KAAKC,IAAIM,KAAKxE,EAAKyE,uBAExBH,QAAQC,IAAI,aAAcvE,EAAKiE,KAAKC,KACpClE,EAAKiE,KAAKS,OAAST,EAAK7D,IAAI,SAACuE,GAK3B,MAJU,CACR7E,IAAK6E,EAAE7E,IACPC,MAAO4E,EAAE5E,SAIbuE,QAAQC,IAAI,sBAAuBvE,EAAKiE,KAAKC,IAAKlE,EAAKiE,KAAKS,QAC5D1E,EAAK+D,SAAS,CAACC,SAAS,OA/BXhE,EAiEnB4E,YAAc,SAACC,GACb7E,EAAK+D,SAAS,CACZe,aAAcD,EAAGE,cAAc9F,IAC/BoD,OAASrC,EAAKiE,KAAKC,IAAIc,KAAK,SAACL,GAAD,OAAOA,EAAE7E,MAAM+E,EAAGE,cAAc9F,MAAMoD,UAlEpErC,EAAKiE,KAAO,CACVS,OAAQ,GACRR,IAAK,IAEPlE,EAAKiF,MAAQ,CACXH,aAAc,SACdzC,OAAQ,GACR2B,SAAS,GAEXhE,EAAKoE,SAAW,qBAXCpE,qFAoCGb,EAAG+F,GACvB,OAAI/F,EAAEkD,OAAO8C,OAASD,EAAE7C,OAAO8C,QACrB,EAEH,kDAGehG,EAAG+F,GACzB,IAAIE,EAAQ,GACRC,EAAQ,GACZD,EAAME,OAAOnG,EAAEkD,OAAOjC,IAAI,SAAAkC,GAAC,OAAIA,EAAEL,YACjCoD,EAAMC,OAAOJ,EAAE7C,OAAOjC,IAAI,SAAAkC,GAAC,OAAIA,EAAEL,YAEjC,IAAIsD,EAAUH,EAAMI,OAAQ,SAACtC,EAAOuC,EAAOC,GACvC,OAAOA,EAAKC,QAAQzC,KAAWuC,IAE/BG,EAAUP,EAAMG,OAAQ,SAACtC,EAAOuC,EAAOC,GACvC,OAAOA,EAAKC,QAAQzC,KAAWuC,IAMpC,OAJCnB,QAAQC,IAAIgB,GACZjB,QAAQC,IAAIqB,GAGTL,EAAQJ,OAASS,EAAQT,OACnB,GAED,mCAUDU,GACN,OAAOC,MAAMD,GACZxB,KAAK,SAAA0B,GACF,IAAKA,EAASC,GACV,MAAM,IAAIC,MAAM,cAAgBF,EAASG,QAE7C,OAAOH,EAASI,SAEnBC,MAAM,WACH,MAAM,IAAIH,MAAM,yDAKrB,OAA2B,IAAvBhG,KAAKgF,MAAMjB,QACN9E,EAAAC,EAAAC,cAAA,wBAKPF,EAAAC,EAAAC,cAACF,EAAAC,EAAMoB,SAAP,KACErB,EAAAC,EAAAC,cAAA,cACEF,EAAAC,EAAAC,cAAA,kDAEFF,EAAAC,EAAAC,cAAA,YACEF,EAAAC,EAAAC,cAAA,aACEF,EAAAC,EAAAC,cAACiH,EAAD,CACElG,MAAOF,KAAKgE,KAAKS,OACjBlF,QAASS,KAAK2E,YACd5F,SAAUiB,KAAKgF,MAAMH,gBAGzB5F,EAAAC,EAAAC,cAACkH,EAAD,CAAUjE,OAAQpC,KAAKgF,MAAM5C,UAE/BnD,EAAAC,EAAAC,cAAA,mCACoBF,EAAAC,EAAAC,cAAA,KAAGmH,KAAK,8BAAR,WADpB,QACyErH,EAAAC,EAAAC,cAAA,KAAGmH,KAAK,6BAAR,mBA5G/D/F,cCKEgG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO5H,EAAAC,EAAAC,cAAC2H,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM/C,KAAK,SAAAgD,GACjCA,EAAaC","file":"static/js/main.17b1bf75.chunk.js","sourcesContent":["import React from 'react';\nimport './FoodImage.css';\n\nexport default function FoodImage(props) {\n  const isSelected = props.selected === props.alt;\n  return (\n    <li className={isSelected ? 'selected' : ''}>\n      <img\n        src={props.link}\n        alt={props.alt}\n        onClick={(e) => props.onClick(e)}\n      />\n      <span>{props.alt}</span>\n    </li>\n  );\n}\n","import React, { Component } from 'react';\nimport FoodImage from '../FoodImage/FoodImage'\nimport './FoodsContainer.css';\n\nclass FoodsContainer extends Component {\n\n  renderFoodItem(item, event, selected) {\n    return (\n      <FoodImage\n        key={item.key}\n        link={item.image}\n        alt={item.key}\n        onClick={event}\n        selected={selected}\n      />\n    );\n  }\n\n  render(props) {\n    const items = this.props.foods.map((i) => {\n      return this.renderFoodItem(i, this.props.onClick, this.props.selected);\n    });\n\n    return (\n      <React.Fragment>\n        <p><strong>Selected food:</strong> {this.props.selected}</p>\n        <section className=\"FoodsContainer\">\n          <ul>\n            {items}\n          </ul>\n        </section>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default FoodsContainer;\n","import React, { Component } from 'react';\nimport L from 'leaflet'\nimport {Map, TileLayer, Marker, Popup } from 'react-leaflet';\nimport './WorldMap.css';\n\nclass WorldMap extends Component {\n  constructor(props) {\n    super(props);\n    this.colors = [\n      'green',\n      'red',\n      'blue',\n      'orange'\n    ]\n    this.markers = {\n      green: L.icon({\n          iconUrl: 'iconGreen.png',\n          iconSize: [20, 20],\n      }),\n      red: L.icon({\n          iconUrl: 'iconRed.png',\n          iconSize: [20, 20],\n      }),\n      blue: L.icon({\n          iconUrl: 'iconBlue.png',\n          iconSize: [20, 20],\n      }),\n      orange: L.icon({\n          iconUrl: 'iconOrange.png',\n          iconSize: [20, 20],\n      }),\n    }\n  }\n\n\n  renderMarker(place, color) {\n    const position = [place.lat, place.lng];\n    return(\n        <Marker key={position[0]+position[1]} position={position} icon={this.markers[color]}>\n          <Popup>\n            {place.name} <br/> {place.synonyms}\n          </Popup>\n        </Marker>\n      )\n\n  }\n\n  render(props) {\n    // console.log(this.props);\n    // console.log(this.props.places);\n    const markerColors = {}\n    let currentColorIndex = 0\n    const markers = this.props.places.map((p) => {\n      let color;\n      for (let s of p.synonyms) {\n        if(markerColors.hasOwnProperty(s)){\n          color = markerColors[s];\n        } else {\n          markerColors[s] = this.colors[currentColorIndex]\n          color = markerColors[s];\n          currentColorIndex += 1;\n        }\n      }\n      return this.renderMarker(p, color)\n    })\n    const zoom = 3;\n    const lat = 40.730610;\n    const lng = -73.935242;\n    const position = [lat, lng];\n    return (\n      <Map center={position} zoom={zoom}>\n        <TileLayer\n          attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n          url='http://{s}.tile.osm.org/{z}/{x}/{y}.png'\n        />\n        {markers}\n      </Map>\n    );\n  }\n}\n\nexport default WorldMap;\n","import React, { Component } from 'react';\nimport FoodsContainer from './FoodsContainer/FoodsContainer';\nimport WorldMap from './WorldMap/WorldMap';\n// import Map from './Map/Map'\n\nimport './App.css';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.data = {\n      images: [],\n      all: {}\n    };\n    this.state = {\n      selectedFood: 'almond',\n      places: [],\n      loading: true,\n    };\n    this.jsonPath = '/distribution.json';\n  };\n\n  componentDidMount = () => {\n    this.setState({loading: true});\n    this.data.all = this.readJson(this.jsonPath)\n      .then((data) => {\n        this.data.all = data\n        console.log('original data', this.data.all);\n        this.data.all.sort(this.comparePlaceFrequency);\n        // this.data.all.sort(this.compareSynonymFrequency);\n        console.log('after sort', this.data.all);\n        this.data.images = data.map((o) => {\n          const n = {\n            key: o.key,\n            image: o.image\n          }\n          return n;\n        });\n        console.log('The data was loaded', this.data.all, this.data.images);\n        this.setState({loading: false});\n      });\n  };\n\n\n  comparePlaceFrequency(a, b) {\n    if (a.places.length > b.places.length) {\n      return -1;\n    }\n    return 1;\n  }\n\n  compareSynonymFrequency(a, b) {\n    let aSyns = [];\n    let bSyns = [];\n    aSyns.concat(a.places.map(p => p.synonyms));\n    bSyns.concat(b.places.map(p => p.synonyms));\n\n    var aUnique = aSyns.filter( (value, index, self) => {\n        return self.indexOf(value) === index;\n    } );\n    var bUnique = bSyns.filter( (value, index, self) => {\n        return self.indexOf(value) === index;\n    } );\n    console.log(aUnique);\n    console.log(bUnique);\n\n\n   if (aUnique.length > bUnique.length) {\n      return 1;\n    }\n    return -1;\n  }\n\n  handleClick = (el) =>  {\n    this.setState({\n      selectedFood: el.currentTarget.alt,\n      places: (this.data.all.find((o) => o.key===el.currentTarget.alt)).places\n    });\n  }\n\n  readJson(path) {\n     return fetch(path)\n     .then(response => {\n         if (!response.ok) {\n             throw new Error(\"HTTP error \" + response.status);\n         }\n         return response.json();\n     })\n     .catch(function () {\n         throw new Error(\"File not available\");\n     })\n  }\n\n  render() {\n    if (this.state.loading === true) {\n      return <h2>Loading...</h2>;\n    }\n\n\n    return (\n      <React.Fragment>\n        <header>\n          <h1>Food language variety visualization</h1>\n        </header>\n        <main>\n          <aside>\n            <FoodsContainer\n              foods={this.data.images}\n              onClick={this.handleClick}\n              selected={this.state.selectedFood}\n            />\n          </aside>\n          <WorldMap places={this.state.places} />\n        </main>\n        <footer>\n          Made with love by <a href=\"https://github.com/nmicht/\">@nmicht</a> and <a href=\"https://github.com/jbrew/\">@jbrew</a>\n        </footer>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}